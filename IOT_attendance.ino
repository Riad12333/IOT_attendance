#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <ArduinoJson.h>
#include <time.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include "config.h"
#include "fingerprint.h"
#include "relay.h"

FingerprintSensor fingerprint;
DoorLock doorLock;
Adafruit_SSD1306 display(128, 64, &Wire, OLED_RESET);

const char* ntpServer = "pool.ntp.org";
const long  gmtOffset_sec = 3600;  // GMT+1
const int   daylightOffset_sec = 3600;

enum Mode {
    MODE_NORMAL,
    MODE_ENROLL
};

Mode currentMode = MODE_NORMAL;
uint16_t nextEnrollId = 0;
bool hasDisplay = false;  // Variable globale pour l'état de l'écran


// --- Bitmaps WiFi et Empreinte validée ---
#define Wifi_connected_width 63
#define Wifi_connected_height 49
const uint8_t PROGMEM Wifi_connected_bits[] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x03,0xff,0xff,0x80,0x00,0x00
,0x00,0x00,0x3f,0xff,0xff,0xf8,0x00,0x00
,0x00,0x01,0xff,0xff,0xff,0xff,0x00,0x00
,0x00,0x0f,0xff,0xff,0xff,0xff,0xe0,0x00
,0x00,0x3f,0xff,0xc0,0x07,0xff,0xf8,0x00
,0x00,0xff,0xf8,0x00,0x00,0x3f,0xfe,0x00
,0x03,0xff,0x80,0x00,0x00,0x03,0xff,0x80
,0x07,0xfe,0x00,0x00,0x00,0x00,0xff,0xc0
,0x1f,0xf8,0x00,0x00,0x00,0x00,0x3f,0xf0
,0x3f,0xe0,0x01,0xff,0xff,0x00,0x0f,0xf8
,0x7f,0x80,0x0f,0xff,0xff,0xe0,0x03,0xfc
,0xff,0x00,0x7f,0xff,0xff,0xfc,0x01,0xfe
,0xfc,0x01,0xff,0xff,0xff,0xff,0x00,0x7e
,0x78,0x07,0xff,0xc0,0x07,0xff,0xc0,0x3c
,0x00,0x0f,0xfc,0x00,0x00,0x7f,0xe0,0x00
,0x00,0x1f,0xf0,0x00,0x00,0x1f,0xf0,0x00
,0x00,0x3f,0xc0,0x00,0x00,0x07,0xf8,0x00
,0x00,0x7f,0x00,0x01,0x00,0x01,0xfc,0x00
,0x00,0x7e,0x00,0x7f,0xfc,0x00,0xfc,0x00
,0x00,0x3c,0x03,0xff,0xff,0x80,0x78,0x00
,0x00,0x00,0x07,0xff,0xff,0xc0,0x00,0x00
,0x00,0x00,0x1f,0xff,0xff,0xf0,0x00,0x00
,0x00,0x00,0x3f,0xf0,0x1f,0xf8,0x00,0x00
,0x00,0x00,0x3f,0x80,0x03,0xf8,0x00,0x00
,0x00,0x00,0x3f,0x00,0x01,0xf8,0x00,0x00
,0x00,0x00,0x1c,0x00,0x00,0x70,0x00,0x00
,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x0f,0xe0,0x00,0x00,0x00
,0x00,0x00,0x00,0x1f,0xf0,0x00,0x00,0x00
,0x00,0x00,0x00,0x3f,0xf8,0x00,0x00,0x00
,0x00,0x00,0x00,0x3f,0xf8,0x00,0x00,0x00
,0x00,0x00,0x00,0x3f,0xf8,0x00,0x00,0x00
,0x00,0x00,0x00,0x3f,0xf8,0x00,0x00,0x00
,0x00,0x00,0x00,0x1f,0xf0,0x00,0x00,0x00
,0x00,0x00,0x00,0x0f,0xe0,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
#define FinPr_valid_width 64
#define FinPr_valid_height 64
const uint8_t PROGMEM FinPr_valid_bits[] = {
  0x00,0x00,0x03,0xfe,0x00,0x00,0x00,0x00
,0x00,0x00,0x1f,0xff,0xe0,0x00,0x00,0x00
,0x00,0x00,0x7f,0xff,0xf8,0x00,0x00,0x00
,0x00,0x00,0xfc,0x00,0xfe,0x00,0x00,0x00
,0x00,0x03,0xe0,0x00,0x1f,0x00,0x00,0x00
,0x00,0x07,0xc0,0x00,0x07,0x80,0x00,0x00
,0x00,0x0f,0x80,0x00,0x03,0xe0,0x00,0x00
,0x00,0x0e,0x03,0xff,0x01,0xe0,0x00,0x00
,0x00,0x1c,0x1f,0xff,0xe0,0xf0,0x00,0x00
,0x00,0x3c,0x3f,0xff,0xf0,0x78,0x00,0x00
,0x00,0x78,0x7c,0x00,0xf8,0x3c,0x00,0x00
,0x00,0x70,0xf0,0x00,0x3c,0x1c,0x00,0x00
,0x00,0xe1,0xe0,0x00,0x1e,0x1c,0x00,0x00
,0x00,0xe1,0xc0,0x00,0x0f,0x0e,0x00,0x00
,0x00,0xc3,0x81,0xfc,0x07,0x0e,0x00,0x00
,0x00,0x03,0x83,0xff,0x07,0x8e,0x00,0x00
,0x00,0x07,0x07,0x8f,0x83,0x87,0x00,0x00
,0x00,0x0f,0x0f,0x03,0xc3,0x87,0x00,0x00
,0x00,0x1e,0x0e,0x01,0xc3,0x87,0x00,0x00
,0x00,0x3c,0x1c,0x00,0xe1,0x87,0x00,0x00
,0x00,0xf8,0x1c,0x30,0xe1,0x87,0x00,0x00
,0x07,0xf0,0x38,0x70,0xe1,0x86,0x00,0x00
,0x07,0xc0,0x78,0x70,0xe3,0x8e,0x00,0x00
,0x02,0x00,0xf0,0xf0,0xe3,0x8e,0x00,0x00
,0x00,0x01,0xe0,0xe0,0xe3,0x8e,0x00,0x00
,0x00,0x03,0xc1,0xe1,0xc3,0x8e,0x00,0x00
,0x00,0x0f,0x83,0xc3,0xc3,0x8e,0x00,0x00
,0x00,0x7f,0x07,0x83,0x83,0x0e,0x00,0x00
,0x07,0xfc,0x0f,0x07,0x83,0x0e,0x00,0x00
,0x07,0xf0,0x1e,0x0f,0x03,0x0e,0x00,0x00
,0x07,0x80,0x7c,0x1e,0x03,0x07,0x00,0x00
,0x00,0x00,0xf8,0x3c,0x03,0x87,0x80,0x00
,0x00,0x03,0xf0,0x78,0x03,0x83,0xc0,0x00
,0x00,0x1f,0xc0,0xf0,0x02,0x00,0x00,0x00
,0x00,0xff,0x01,0xe1,0xc0,0x0c,0x00,0x00
,0x07,0xfc,0x03,0xc3,0xe1,0xff,0xc0,0x00
,0x07,0xe0,0x0f,0x87,0xc7,0xff,0xf0,0x00
,0x07,0x00,0x3f,0x0f,0x0f,0xff,0xfc,0x00
,0x00,0x00,0x7c,0x3e,0x3f,0xff,0xfe,0x00
,0x00,0x03,0xf8,0x7c,0x3f,0xff,0xff,0x00
,0x00,0x1f,0xe0,0xf0,0x7f,0xff,0xff,0x80
,0x00,0xff,0x83,0xe0,0xff,0xff,0xff,0x80
,0x01,0xfc,0x07,0xc1,0xff,0xff,0xe3,0xc0
,0x01,0xe0,0x1f,0x01,0xff,0xff,0xc3,0xc0
,0x00,0x00,0xfe,0x01,0xff,0xff,0x87,0xe0
,0x00,0x03,0xf8,0x13,0xff,0xff,0x0f,0xe0
,0x00,0x1f,0xe0,0x73,0xff,0xfe,0x1f,0xe0
,0x00,0x7f,0x81,0xf3,0xff,0xfc,0x1f,0xe0
,0x00,0xfc,0x03,0xe3,0xef,0xf8,0x3f,0xe0
,0x00,0x60,0x0f,0xc3,0xc7,0xf0,0x7f,0xe0
,0x00,0x00,0x3f,0x03,0xc3,0xe0,0xff,0xe0
,0x00,0x00,0xfc,0x03,0xc1,0xc1,0xff,0xe0
,0x00,0x07,0xf0,0x13,0xe0,0x83,0xff,0xe0
,0x00,0x0f,0xc0,0x7b,0xf8,0x07,0xff,0xe0
,0x00,0x0f,0x01,0xf9,0xfc,0x0f,0xff,0xc0
,0x00,0x00,0x07,0xf1,0xfe,0x1f,0xff,0xc0
,0x00,0x00,0x1f,0xc0,0xff,0x3f,0xff,0x80
,0x00,0x00,0x7e,0x00,0xff,0xff,0xff,0x80
,0x00,0x00,0xfc,0x00,0x7f,0xff,0xff,0x00
,0x00,0x00,0xf0,0x1f,0x3f,0xff,0xfe,0x00
,0x00,0x00,0x00,0x7f,0x1f,0xff,0xfc,0x00
,0x00,0x00,0x01,0xff,0x8f,0xff,0xf8,0x00
,0x00,0x00,0x03,0xe0,0xe3,0xff,0xe0,0x00
,0x00,0x00,0x01,0x80,0x00,0x7f,0x00,0x00
};
#define FinPr_invalid_width 64
#define FinPr_invalid_height 64
const uint8_t PROGMEM FinPr_invalid_bits[] = {
  0x00,0x00,0x03,0xfe,0x00,0x00,0x00,0x00
,0x00,0x00,0x1f,0xff,0xe0,0x00,0x00,0x00
,0x00,0x00,0x7f,0xff,0xf8,0x00,0x00,0x00
,0x00,0x00,0xfc,0x00,0xfe,0x00,0x00,0x00
,0x00,0x03,0xe0,0x00,0x1f,0x00,0x00,0x00
,0x00,0x07,0xc0,0x00,0x07,0x80,0x00,0x00
,0x00,0x0f,0x80,0x00,0x03,0xe0,0x00,0x00
,0x00,0x0e,0x03,0xff,0x01,0xe0,0x00,0x00
,0x00,0x1c,0x1f,0xff,0xe0,0xf0,0x00,0x00
,0x00,0x3c,0x3f,0xff,0xf0,0x78,0x00,0x00
,0x00,0x78,0x7c,0x00,0xf8,0x3c,0x00,0x00
,0x00,0x70,0xf0,0x00,0x3c,0x1c,0x00,0x00
,0x00,0xe1,0xe0,0x00,0x1e,0x1c,0x00,0x00
,0x00,0xe1,0xc0,0x00,0x0f,0x0e,0x00,0x00
,0x00,0xc3,0x81,0xfc,0x07,0x0e,0x00,0x00
,0x00,0x03,0x83,0xff,0x07,0x8e,0x00,0x00
,0x00,0x07,0x07,0x8f,0x83,0x87,0x00,0x00
,0x00,0x0f,0x0f,0x03,0xc3,0x87,0x00,0x00
,0x00,0x1e,0x0e,0x01,0xc3,0x87,0x00,0x00
,0x00,0x3c,0x1c,0x00,0xe1,0x87,0x00,0x00
,0x00,0xf8,0x1c,0x30,0xe1,0x87,0x00,0x00
,0x07,0xf0,0x38,0x70,0xe1,0x86,0x00,0x00
,0x07,0xc0,0x78,0x70,0xe3,0x8e,0x00,0x00
,0x02,0x00,0xf0,0xf0,0xe3,0x8e,0x00,0x00
,0x00,0x01,0xe0,0xe0,0xe3,0x8e,0x00,0x00
,0x00,0x03,0xc1,0xe1,0xc3,0x8e,0x00,0x00
,0x00,0x0f,0x83,0xc3,0xc3,0x8e,0x00,0x00
,0x00,0x7f,0x07,0x83,0x83,0x0e,0x00,0x00
,0x07,0xfc,0x0f,0x07,0x83,0x0e,0x00,0x00
,0x07,0xf0,0x1e,0x0f,0x03,0x0e,0x00,0x00
,0x07,0x80,0x7c,0x1e,0x03,0x07,0x00,0x00
,0x00,0x00,0xf8,0x3c,0x03,0x87,0x80,0x00
,0x00,0x03,0xf0,0x78,0x03,0x83,0xc0,0x00
,0x00,0x1f,0xc0,0xf0,0x02,0x00,0x00,0x00
,0x00,0xff,0x01,0xe1,0xc0,0x0c,0x00,0x00
,0x07,0xfc,0x03,0xc3,0xe1,0xff,0xc0,0x00
,0x07,0xe0,0x0f,0x87,0xc7,0xff,0xf0,0x00
,0x07,0x00,0x3f,0x0f,0x0f,0xff,0xf8,0x00
,0x00,0x00,0x7c,0x3e,0x1f,0xff,0xfe,0x00
,0x00,0x03,0xf8,0x7c,0x3f,0xff,0xff,0x00
,0x00,0x1f,0xe0,0xf0,0x7f,0xff,0xff,0x00
,0x00,0xff,0x83,0xe0,0xfe,0xff,0xbf,0x80
,0x01,0xfc,0x07,0xc0,0xfc,0x7f,0x1f,0xc0
,0x01,0xe0,0x1f,0x01,0xf8,0x3e,0x0f,0xc0
,0x00,0x00,0xfe,0x01,0xf8,0x1c,0x07,0xe0
,0x00,0x03,0xf8,0x13,0xf8,0x00,0x0f,0xe0
,0x00,0x1f,0xe0,0x73,0xfc,0x00,0x1f,0xe0
,0x00,0x7f,0x81,0xf3,0xfe,0x00,0x3f,0xe0
,0x00,0xfc,0x03,0xe3,0xff,0x00,0x7f,0xe0
,0x00,0x60,0x0f,0xc3,0xff,0x80,0xff,0xe0
,0x00,0x00,0x3f,0x03,0xff,0x00,0x7f,0xe0
,0x00,0x00,0xfc,0x03,0xfe,0x00,0x3f,0xe0
,0x00,0x07,0xf0,0x13,0xfc,0x00,0x1f,0xe0
,0x00,0x0f,0xc0,0x79,0xf8,0x08,0x0f,0xe0
,0x00,0x0f,0x01,0xf9,0xf8,0x1c,0x0f,0xc0
,0x00,0x00,0x07,0xf1,0xfc,0x3e,0x1f,0xc0
,0x00,0x00,0x1f,0xc0,0xfe,0x7f,0x3f,0x80
,0x00,0x00,0x7e,0x00,0xff,0xff,0xff,0x80
,0x00,0x00,0xfc,0x00,0x7f,0xff,0xff,0x00
,0x00,0x00,0xf0,0x1f,0x3f,0xff,0xfe,0x00
,0x00,0x00,0x00,0x7f,0x1f,0xff,0xfc,0x00
,0x00,0x00,0x01,0xff,0x8f,0xff,0xf8,0x00
,0x00,0x00,0x03,0xe0,0xe3,0xff,0xe0,0x00
,0x00,0x00,0x01,0x80,0x00,0x7f,0x00,0x00
};
// --- Fin bitmaps ---

void setup() {
    Serial.begin(9600);
    delay(1000);  // Attendre que le port série soit prêt
    Serial.println("Démarrage...");

    // Initialisation de l'écran OLED (optionnel)
    hasDisplay = display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
    if(!hasDisplay) {
        Serial.println("Écran OLED non détecté - Mode console uniquement");
    } else {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(WHITE);
        display.setCursor(0,0);
        display.println("Initialisation...");
        display.display();
    }
    
    // Initialisation du capteur d'empreintes
    Serial.println("Initialisation du capteur d'empreintes...");
    if (!fingerprint.begin()) {
        Serial.println("Capteur d'empreintes non trouvé !");
        if(hasDisplay) {
            display.clearDisplay();
            display.setCursor(0,0);
            display.println("Erreur capteur");
            display.println("empreintes!");
            display.display();
        }
        while (1) { delay(1); }
    }
    Serial.println("Capteur d'empreintes OK!");
    
    // Configuration WiFi
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    Serial.print("Connexion au WiFi");
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 20) {
        delay(500);
        Serial.print(".");
        attempts++;
    }
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("\nÉchec de connexion WiFi!");
        if(hasDisplay) {
            display.clearDisplay();
            display.setCursor(0,0);
            display.println("Erreur WiFi!");
            display.display();
        }
        while (1) { delay(1); }
    }
    Serial.println("\nConnecté au WiFi!");
    
    // Configuration NTP
    configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
    
    // Initialisation de l'écran OLED
    if(hasDisplay) {
        display.clearDisplay();
        display.setCursor(0,0);
        display.println("Initialisation...");
        display.display();
    }

    // Connexion WiFi
    if(hasDisplay) {
        display.clearDisplay();
        display.setCursor(0,0);
        display.println("Connexion WiFi...");
        display.display();
    }
    
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    while (WiFi.status() != WL_CONNECTED) {
        delay(500);
        Serial.print(".");
        if(hasDisplay) {
            display.print(".");
            display.display();
        }
    }
    
    if(hasDisplay) {
        display.clearDisplay();
        display.setTextSize(1);
        display.setTextColor(WHITE);
        display.setCursor(0,0);
        display.println("Connected");
        display.drawBitmap(32, 8, Wifi_connected_bits, Wifi_connected_width, Wifi_connected_height, WHITE);
        display.display();
        delay(2000);
    }

    showMainMenu();
}

void showMainMenu() {
    if(hasDisplay) {
        display.clearDisplay();
        display.setCursor(0,0);
        display.println("=== Mode d'emploi ===");
        display.println("E: Mode enregistrement");
        display.println("N: Mode normal");
        display.println("P/S: Type utilisateur");
        display.display();
    }
    
    Serial.println("\n=== Mode d'emploi ===");
    Serial.println("1. Mode normal : Le système vérifie les empreintes et gère les accès");
    Serial.println("2. Mode enregistrement : Pour enregistrer de nouvelles empreintes");
    Serial.println("\nCommandes disponibles :");
    Serial.println("'E' : Entrer en mode enregistrement");
    Serial.println("'N' : Retourner au mode normal");
    Serial.println("'P' : En mode enregistrement, définir l'ID comme professeur");
    Serial.println("'S' : En mode enregistrement, définir l'ID comme étudiant");
}

void loop() {
    if (Serial.available()) {
        char cmd = Serial.read();
        handleCommand(cmd);
    }

    if (currentMode == MODE_NORMAL) {
        handleNormalMode();
    } else {
        handleEnrollMode();
    }
    
    delay(50);
}

void handleCommand(char cmd) {
    switch (cmd) {
        case 'E':
        case 'e':
            currentMode = MODE_ENROLL;
            if(hasDisplay) {
                display.clearDisplay();
                display.setCursor(0,0);
                display.println("Mode Enregistrement");
                display.println("P: Professeur");
                display.println("S: Etudiant");
                display.display();
            }
            break;
            
        case 'N':
        case 'n':
            currentMode = MODE_NORMAL;
            if(hasDisplay) {
                display.clearDisplay();
                display.setCursor(0,0);
                display.println("Mode Normal");
                display.println("En attente...");
                display.println("Placer votre doigt");
                display.display();
            }
            Serial.println("Mode Normal : Placer votre doigt");
            break;
            
        case 'P':
        case 'p':
            if (currentMode == MODE_ENROLL) {
                nextEnrollId = getNextAvailableId(true);
                if(hasDisplay) {
                    display.clearDisplay();
                    display.setCursor(0,0);
                    display.println("Nouvel enseignant");
                    display.printf("ID: %d\n", nextEnrollId);
                    display.println("Placez le doigt...");
                    display.display();
                }
            }
            break;
            
        case 'S':
        case 's':
            if (currentMode == MODE_ENROLL) {
                nextEnrollId = getNextAvailableId(false);
                if(hasDisplay) {
                    display.clearDisplay();
                    display.setCursor(0,0);
                    display.println("Nouvel etudiant");
                    display.printf("ID: %d\n", nextEnrollId);
                    display.println("Placez le doigt...");
                    display.display();
                }
            }
            break;
    }
}

void handleNormalMode() {
    int fingerprintID = fingerprint.getFingerprintID();

    if (fingerprintID == -2) {
        if(hasDisplay) {
            display.clearDisplay();
            display.drawBitmap(32, 0, FinPr_invalid_bits, FinPr_invalid_width, FinPr_invalid_height, WHITE);
            display.display();
            delay(1500);
        }
        Serial.println("Empreinte non reconnue !");
        return;
    }
    // Si aucun doigt, ne rien faire
    if (fingerprintID == -1) return;
    // Si autre erreur, ne rien faire
    if (fingerprintID <= 0) return;

    if (fingerprintID > 0) {
        if(hasDisplay) {
            display.clearDisplay();
            display.drawBitmap(32, 0, FinPr_valid_bits, FinPr_valid_width, FinPr_valid_height, WHITE);
            display.display();
            delay(1500);
        }
        
        if (fingerprintID <= MAX_PROFESSOR_ID) {
            handleProfessorAccess(fingerprintID);
        } else {
            handleStudentAttendance(fingerprintID);
        }
    }
}

void handleEnrollMode() {
    if (nextEnrollId > 0) {
        if (fingerprint.enrollFingerprint(nextEnrollId)) {
            if(hasDisplay) {
                display.clearDisplay();
                display.setCursor(0,0);
                display.println("Enregistre!");
                display.printf("ID: %d\n", nextEnrollId);
                display.println(nextEnrollId <= MAX_PROFESSOR_ID ? "Type: Prof" : "Type: Etudiant");
                display.display();
                delay(2000);
            }
            
            // Envoyer l'ID au serveur
            bool isProfessor = (nextEnrollId <= MAX_PROFESSOR_ID);
            if (sendFingerprintIdToServer(nextEnrollId, isProfessor)) {
                Serial.println("ID envoyé au serveur avec succès!");
                if(hasDisplay) {
                    display.clearDisplay();
                    display.setCursor(0,0);
                    display.println("ID envoye au");
                    display.println("serveur!");
                    display.display();
                    delay(2000);
                }
            } else {
                Serial.println("Erreur lors de l'envoi au serveur");
                if(hasDisplay) {
                    display.clearDisplay();
                    display.setCursor(0,0);
                    display.println("Erreur envoi");
                    display.println("au serveur!");
                    display.display();
                    delay(2000);
                }
            }
            
            nextEnrollId = 0;
            showMainMenu();
        }
    }
}

uint16_t getNextAvailableId(bool isProfessor) {
    uint16_t startId, endId;
    if (isProfessor) {
        startId = 1;
        endId = MAX_PROFESSOR_ID;
    } else {
        startId = MAX_PROFESSOR_ID + 1;
        endId = 127; // Limite max du capteur AS608
    }

    for (uint16_t id = startId; id <= endId; id++) {
        if (!fingerprint.isIdUsed(id)) { // Si l'ID n'est pas utilisé
            return id;
        }
    }
    return 0; // Plus de place
}

void handleProfessorAccess(int fingerprintID) {
    if (verifyProfessorAccess(fingerprintID)) {
        if(hasDisplay) {
            display.clearDisplay();
            display.setCursor(0,0);
            display.println("Acces autorise!");
            display.println("Professeur");
            display.display();
        }
        Serial.println("Accès autorisé - Professeur");
        doorLock.open();
    } else {
        if(hasDisplay) {
            display.clearDisplay();
            display.setCursor(0,0);
            display.println("Acces refuse!");
            display.println("Professeur");
            display.display();
        }
        Serial.println("Accès refusé - Professeur");
    }
}

void handleStudentAttendance(int fingerprintID) {
    if (recordStudentAttendance(fingerprintID)) {
        if(hasDisplay) {
            display.clearDisplay();
            display.setCursor(0,0);
            display.println("Presence enregistree!");
            display.println("Etudiant");
            display.display();
        }
        Serial.println("Présence enregistrée - Étudiant");
    } else {
        if(hasDisplay) {
            display.clearDisplay();
            display.setCursor(0,0);
            display.println("Erreur enregistrement!");
            display.println("Etudiant");
            display.display();
        }
        Serial.println("Erreur lors de l'enregistrement de la présence");
    }
}

bool verifyProfessorAccess(int fingerprintID) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("Erreur: Pas de connexion WiFi");
        return false;
    }

    HTTPClient http;
    WiFiClient client;
    http.begin(client, SERVER2_URL);
    http.addHeader("Content-Type", "application/json");

    struct tm timeinfo;
    if(!getLocalTime(&timeinfo)) {
        Serial.println("Erreur: Impossible d'obtenir l'heure");
        return false;
    }
    time_t timestamp = mktime(&timeinfo);

    StaticJsonDocument<300> doc;
    doc["fingerprintId"] = fingerprintID;  
    doc["roomId"] = atoi(ROOM_ID);         
    doc["timestamp"] = timestamp;
    
    String jsonString;
    serializeJson(doc, jsonString);
    Serial.print("Envoi des données au serveur professeur: ");
    Serial.println(jsonString);

    int httpCode = http.POST(jsonString);
    
    if (httpCode <= 0) {
        Serial.printf("Erreur HTTP: %s\n", http.errorToString(httpCode).c_str());
        http.end();
        return false;
    }

    if (httpCode == 200) {
        String payload = http.getString();
        StaticJsonDocument<300> response;
        DeserializationError error = deserializeJson(response, payload);
        
        if (error) {
            Serial.println("Erreur de parsing JSON");
            return false;
        } else {
            bool success = response["success"].as<bool>();
            if (success) {
                const char* action = response["data"]["action"].as<const char*>();
                if (strcmp(action, "UNLOCK") == 0) {
                    Serial.println("Accès autorisé - Ouverture de la porte");
                    return true;
                }
            }
        }
    }
    
    Serial.println("Accès refusé");
    http.end();
    return false;
}

bool recordStudentAttendance(int fingerprintID) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("Erreur: Pas de connexion WiFi");
        return false;
    }

    HTTPClient http;
    WiFiClient client;
    http.begin(client, SERVER1_URL);
    http.addHeader("Content-Type", "application/json");

    struct tm timeinfo;
    if(!getLocalTime(&timeinfo)) {
        Serial.println("Erreur: Impossible d'obtenir l'heure");
        return false;
    }
    time_t timestamp = mktime(&timeinfo);

    StaticJsonDocument<300> doc;
    doc["fingerprint_id"] = fingerprintID;
    doc["roomId"] = atoi(ROOM_ID);         
    doc["timestamp"] = timestamp;
    
    String jsonString;
    serializeJson(doc, jsonString);
    Serial.print("Envoi des données au serveur étudiant: ");
    Serial.println(jsonString);

    int httpCode = http.POST(jsonString);
    
    if (httpCode <= 0) {
        Serial.printf("Erreur HTTP: %s\n", http.errorToString(httpCode).c_str());
        http.end();
        return false;
    }

    bool success = (httpCode == 200);
    if (success) {
        Serial.println("Présence enregistrée avec succès");
    } else {
        Serial.println("Erreur lors de l'enregistrement de la présence");
    }
    
    http.end();
    return success;
}

// Fonction pour envoyer l'ID au serveur
bool sendFingerprintIdToServer(uint16_t fingerprintId, bool isProfessor) {
    if (WiFi.status() != WL_CONNECTED) {
        Serial.println("Erreur: Pas de connexion WiFi");
        return false;
    }

    HTTPClient http;
    WiFiClient client;
    http.begin(client, SERVER3_URL);
    http.addHeader("Content-Type", "application/json");

    StaticJsonDocument<200> doc;
    doc["fingerprint_id"] = fingerprintId;
    doc["is_professor"] = isProfessor;
    doc["template_data"] = "template"; // Le template réel sera géré par le serveur
    
    String jsonString;
    serializeJson(doc, jsonString);
    Serial.print("Envoi des données au serveur: ");
    Serial.println(jsonString);

    int httpCode = http.POST(jsonString);
    
    if (httpCode <= 0) {
        Serial.printf("Erreur HTTP: %s\n", http.errorToString(httpCode).c_str());
        http.end();
        return false;
    }

    if (httpCode == 200) {
        String payload = http.getString();
        Serial.println("Réponse du serveur: " + payload);
        http.end();
        return true;
    }
    
    Serial.println("Erreur lors de l'envoi au serveur");
    http.end();
    return false;
}
